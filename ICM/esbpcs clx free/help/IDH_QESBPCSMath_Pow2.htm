<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<META NAME="GENERATOR" Content="Time2HELP 1.0; Standard Template">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
<TITLE>Pow2</TITLE>
<Style>Body, TD {font-family: "Verdana"; font-size: 10pt};
PRE {font-size: 10pt; margin-top: 0; margin-bottom: 0}
TR.odd {background-color: #F8F8F8};
TR.even {background-color: #EEEEEE};
Table.list {background-color: #FFFFFF};
TD {vertical-align : top}
</Style>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<BASEFONT NAME="verdana" Size="2"><Table Border="0" Width="100%" BGColor="#FFFFFF"><TR><TD><Font Color="#000000F"><B>Pow2 Function</B></Font></TD></TR></Table>Calculate 2 to the given floating point power.<P><B>Unit</B><Br><A HREF="IDH_Unit_QESBPCSMath.htm">QESBPCSMath</A><P><B>Declaration</B><Br><Font Face="Courier New"><B>Function</B> Pow2(<B>const</B> X: Extended): Extended;</Font><P><B>Description</B><Br />Developed by Rory Daulton and used with permission. December 1998.</P><P>EOverflow Exception when X &gt;= 16384. (if there was no other FPU error condition, such as underflow or denormal, before entry to this routine)</P><P>EInvalidOp Exception on some occasions when EOverflow would be expected, due to some other FPU error condition (such as underflow) before entry to this routine.</P><P>NOTES: 1. This routine is faster and more accurate than Power(2, X). It is also faster and more accurate than Exp(X), so if exponentials and logarithms are needed in a program and the base is not important, use Pow2 and Log2 rather than Exp and Ln or even Power(10, X) and Log10.</P><P>2. The algorithm used is to scale the power of the fractional part of X, using FPU commands.</P><P>3. Although the FPU (Floating Point Unit) is used, the answer is exact for integral X, since the FSCALE FPU command is.</P><P>4. The result underflows to zero at a little less than -16445 and is a normal Extended value for -16382 &lt;= X &lt; 16384.</P><P>5. The comments in the code assume that the FPU rounding is set to banker's rounding. The code should work for any kind of rounding, but the precise integer and fractional parts of X would vary depending on the rounding.</P><P><Font Color=#FF0000><H3>Implementation</H3></Font> <table border="0" bgcolor="#FFFED9"  style="margin-top: 10; margin-bottom: 10;"> <tr> <td><pre><B>function</B> Pow2 (<B>const</B> X: Extended): Extended;
<B>asm</B>
	   fld     X
<Font Color="#0000DD">// find Round(X)</Font>
	   fld     st
	   frndint
<Font Color="#0000DD">// find _Frac(X) [minimal fractional part of X, between -0.5 and 0.5]</Font>
	   fsub    st(1),st
	   fxch    st(1)
<Font Color="#0000DD">// Find 2**_Frac(X)</Font>
	   f2xm1
	   fld1
	   fadd
<Font Color="#0000DD">// Result := 2**_Frac(X) * 2**Round(X)</Font>
	   fscale
	   fstp    st(1)
	   fwait
<B>End</B>;</pre></td></tr></Table><P><HR>
<TABLE BORDER="0" WIDTH="100%" BGCOLOR="#000000"><TR><TD>
<Font Color=White><Large>HTML generated by <B>Time2HELP</B></Large></Font>
</TD></TR></Table>
<Small><A HREF="http://www.time2help.com">http://www.time2help.com</A></Small></Body></HTML>