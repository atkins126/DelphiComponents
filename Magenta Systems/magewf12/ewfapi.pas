unit EWFAPI;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date: 13/11/2004                                            }
{    Generated Time: 14:38:39                                              }
{ 1.1 - 5th August 2008   - updated to be compatible with Delphi 2009      }
{ 1.2 - 8th April 2009    - added MINENUMSIZE 4 so that enumerated         }
{                           variables are correct length for C++, thanks   }
{                           to Sven van Bruegge                            }
{                                                                          }
{**************************************************************************}

interface
uses  Windows;


{=> EWFAPI.H <=}

{+//*************************************************************************** }

{-Copyright (c) 2003 Microsoft Corporation }

{-Module Name: }

{-ewfapi.h }

{-Abstract: }

{-Defines the EWF APIs }

{-Environment: }

{-User mode }

{-Revision History: }


{=*************************************************************************** }

// type enum to set
// in Delphi by default a set (enumeration type) is 1 byte, in C it is 4 byte
// if you don't set this compiler directive the stucture has the wrong length
// see Delphi Help for {$MINENUMSIZE 4}
{$MINENUMSIZE 4}

type
  USHORT = Word ;

  PEWF_VOLUME_NAME_ENTRY = ^_EWF_VOLUME_NAME_ENTRY;
  _EWF_VOLUME_NAME_ENTRY = record
    Next: PEWF_VOLUME_NAME_ENTRY;
    Name: Array[0..1-1] of WCHAR;
  end {_EWF_VOLUME_NAME_ENTRY};
  EWF_VOLUME_NAME_ENTRY = _EWF_VOLUME_NAME_ENTRY;

  EWF_CMD = (EWF_NO_CMD, EWF_ENABLE, EWF_DISABLE, EWF_SET_LEVEL, EWF_COMMIT  );
  EWF_STATE = (EWF_ENABLED, EWF_DISABLED  );
  EWF_TYPE = (EWF_DISK, EWF_RAM, EWF_RAM_REG );

const
  EWF_MAX_DEVICE_NAME_LENGTH = (256);
  EWF_VOLUME_ID_SIZE = (16);

type
  _EWF_VOLUME_DESC = record
    DeviceName: Array[0..EWF_MAX_DEVICE_NAME_LENGTH-1] of WCHAR;
    VolumeID: Array[0..EWF_VOLUME_ID_SIZE-1] of AnsiChar;
  end {_EWF_VOLUME_DESC};
  EWF_VOLUME_DESC = _EWF_VOLUME_DESC;
  PEWF_VOLUME_DESC = ^_EWF_VOLUME_DESC;


{/// }
{/// This is a variable size structure depending on how many protected overlay }
{/// volumes there are. }
{/// }
type
  _EWF_OVERLAY_STORE_CONFIG = record
    FormatVersion: ULONG;
    VolumeSize: LONGLONG;
    NumSegments: ULONG;
    FreeSegments: ULONG;
    SegmentSize: ULONG;
    MaxVolumes: ULONG;
    NumVolumes: ULONG;
    MaxLevels: USHORT;
    VolumeDescArray: Array[0..1-1] of EWF_VOLUME_DESC;
{/// The array holds NumVolume count volume descriptions }
  end {_EWF_OVERLAY_STORE_CONFIG};
  EWF_OVERLAY_STORE_CONFIG = _EWF_OVERLAY_STORE_CONFIG;
  PEWF_OVERLAY_STORE_CONFIG = ^_EWF_OVERLAY_STORE_CONFIG;

type
  _EWF_COMMAND = record
    Command: EWF_CMD;
    Param1: ULONG;
    Param2: ULONG;
  end {_EWF_COMMAND};
  EWF_COMMAND = _EWF_COMMAND;
  PEWF_COMMAND = ^_EWF_COMMAND;


const
  EWF_MAX_LEVEL_NAME_LENGTH = (64);

type
  _EWF_LEVEL_DESC = record
    LevelName: Array[0..EWF_MAX_LEVEL_NAME_LENGTH-1] of WCHAR;
// friendly name of the level
// If the length is equal to EWF_MAX_LEVEL_NAME_LENGTH
// then no null terminator is stored.
    LevelEndTime: FILETIME;   // time at which the level was ended
    LevelDataSize: LONGLONG;  // Size of the data in the level in bytes
  end {_EWF_LEVEL_DESC};
  EWF_LEVEL_DESC = _EWF_LEVEL_DESC;
  PEWF_LEVEL_DESC = ^_EWF_LEVEL_DESC;

const
  EWF_MAX_PERSISTENT_DATA = (32); {// maximum number of bytes that can be persisted}

type
  TDiskOverlay = record
      DiskMapSize: LONGLONG;      // Size of the mapping data on disk
      DiskDataSize: LONGLONG;     // Size of the data stored on disk for this protected volume
  end ;

  TRamOverlay = record
    RamDataSize: LONGLONG;        // Size of the data stored in RAM for this protected volume
  end {RamOverlay};

  _EWF_VOLUME_CONFIG = record
    VType: EWF_TYPE;      // Type of overlay for this volume
    State: EWF_STATE;     // state of the overlay for this volume, ENABLED or DISABLED
    BootCommand: EWF_COMMAND;    // Command to execute on next restart
    PersistentData: Array[0..EWF_MAX_PERSISTENT_DATA-1] of AnsiChar;
                            // Small amount of persistent data that survives a restore
    MaxLevels: USHORT;      // Maximum number of checkpoint levels for this volume
    ClumpSize: ULONG;       // 512 bytes
    CurrentLevel: USHORT;   // Current checkpoint level
    DiskOverlay: TDiskOverlay ;
    RamOverlay: TRamOverlay ;
	MemMapSize: USHORT;			// Size of the mapping data in memory
	VolumeDesc: EWF_VOLUME_DESC ;		// volume device name, and volume ID
    LevelDescArray: array [0..1-1] of EWF_LEVEL_DESC ; // Level descripton and end time, and level data size
  end {EWF_VOLUME_CONFIG};
  EWF_VOLUME_CONFIG = _EWF_VOLUME_CONFIG ;
  PEWF_VOLUME_CONFIG = ^_EWF_VOLUME_CONFIG ;

var
  EwfMgrGetDriveLetterFromVolumeName: function(lpVolumeName: LPCWSTR): WCHAR ; stdcall;
  EwfMgrVolumeNameListIsEmpty: function(pVolumeNameList: PEWF_VOLUME_NAME_ENTRY): BOOL ; stdcall;
  EwfMgrVolumeNameEntryPop: function(var ppVolumeNameList: PEWF_VOLUME_NAME_ENTRY): BOOL ; stdcall;
  EwfMgrVolumeNameListDelete: procedure(pVolumeNameList: PEWF_VOLUME_NAME_ENTRY); stdcall;
  EwfMgrOpenProtected: function(lpVolume: LPCWSTR): THANDLE ; stdcall;
  EwfMgrClose: function(hDevice: THANDLE): BOOL ; stdcall;
  EwfMgrClearCommand: function(hDevice: THANDLE): BOOL stdcall;
  EwfMgrSetPersistentData: function(hDevice: THANDLE; lpPersistentData: Pointer;
                                                cbPersistentData: DWORD): BOOL ; stdcall;
  EwfMgrGetPersistentData: function(hDevice: THANDLE; var lpPersistentData: Pointer;
                                                cbPersistentData: DWORD): BOOL ; stdcall;
  EwfMgrCheckpoint: function(hDevice: THANDLE; lpDescription: LPCWSTR): BOOL ; stdcall;
  EwfMgrRestore: function(hDevice: THANDLE): BOOL ; stdcall;
  EwfMgrDisable: function(hDevice: THANDLE; fCommit: BOOL): BOOL ; stdcall;
  EwfMgrEnable: function(hDevice: THANDLE): BOOL ; stdcall;
  EwfMgrCommit: function(hDevice: THANDLE): BOOL ; stdcall;
  EwfMgrSetLevel: function(hDevice: THANDLE; lpDescription: LPCWSTR;
                                           Level: integer; fDeleteLevel: BOOL): BOOL ; stdcall;
  EwfMgrGetProtectedVolumeConfig: function(hDevice: THANDLE): PEWF_VOLUME_CONFIG ; stdcall;
  EwfMgrGetProtectedVolumeList: function: PEWF_VOLUME_NAME_ENTRY ; stdcall;
  EwfMgrOpenOverlayStore: function(fOpenForAsyncIO: BOOL): THANDLE ; stdcall;
  EwfMgrGetOverlayStoreConfig: function(hDevice: THANDLE): PEWF_OVERLAY_STORE_CONFIG ; stdcall;
  EwfMgrRegisterLowSpaceNotification: function(hDevice: THANDLE;
                     FreeBytesRemaining: LONGLONG; lpOverlapped: TOverlapped): BOOL ; stdcall;

var
  EwfDLLLoaded: Boolean { is DLL (dynamically) loaded already? }
    {$IFDEF WIN32} = False; {$ENDIF}

procedure EwfLoadDLL;

implementation

var
  SaveExit: pointer;
  DLLHandle: THandle;
{$IFNDEF MSDOS}
  ErrorMode: Integer;
{$ENDIF}

  procedure NewExit; far;
  begin
    ExitProc := SaveExit;
    FreeLibrary(DLLHandle)
  end {NewExit};

procedure EwfLoadDLL;
begin
  if EwfDLLLoaded then Exit;
{$IFNDEF MSDOS}
  ErrorMode := SetErrorMode($8000{SEM_NoOpenFileErrorBox});
{$ENDIF}
  DLLHandle := LoadLibrary('EWFAPI.DLL');
  if DLLHandle >= 32 then
  begin
    EwfDLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    @EwfMgrGetDriveLetterFromVolumeName := GetProcAddress(DLLHandle,'EwfMgrGetDriveLetterFromVolumeName');
  {$IFDEF WIN32}
    Assert(@EwfMgrGetDriveLetterFromVolumeName <> nil);
  {$ENDIF}
    @EwfMgrVolumeNameListIsEmpty := GetProcAddress(DLLHandle,'EwfMgrVolumeNameListIsEmpty');
  {$IFDEF WIN32}
    Assert(@EwfMgrVolumeNameListIsEmpty <> nil);
  {$ENDIF}
    @EwfMgrVolumeNameEntryPop := GetProcAddress(DLLHandle,'EwfMgrVolumeNameEntryPop');
  {$IFDEF WIN32}
    Assert(@EwfMgrVolumeNameEntryPop <> nil);
  {$ENDIF}
    @EwfMgrVolumeNameListDelete := GetProcAddress(DLLHandle,'EwfMgrVolumeNameListDelete');
  {$IFDEF WIN32}
    Assert(@EwfMgrVolumeNameListDelete <> nil);
  {$ENDIF}
    @EwfMgrOpenProtected := GetProcAddress(DLLHandle,'EwfMgrOpenProtected');
  {$IFDEF WIN32}
    Assert(@EwfMgrOpenProtected <> nil);
  {$ENDIF}
    @EwfMgrClose := GetProcAddress(DLLHandle,'EwfMgrClose');
  {$IFDEF WIN32}
    Assert(@EwfMgrClose <> nil);
  {$ENDIF}
    @EwfMgrClearCommand := GetProcAddress(DLLHandle,'EwfMgrClearCommand');
  {$IFDEF WIN32}
    Assert(@EwfMgrClearCommand <> nil);
  {$ENDIF}
    @EwfMgrSetPersistentData := GetProcAddress(DLLHandle,'EwfMgrSetPersistentData');
  {$IFDEF WIN32}
    Assert(@EwfMgrSetPersistentData <> nil);
  {$ENDIF}
    @EwfMgrGetPersistentData := GetProcAddress(DLLHandle,'EwfMgrGetPersistentData');
  {$IFDEF WIN32}
    Assert(@EwfMgrGetPersistentData <> nil);
  {$ENDIF}
    @EwfMgrCheckpoint := GetProcAddress(DLLHandle,'EwfMgrCheckpoint');
  {$IFDEF WIN32}
    Assert(@EwfMgrCheckpoint <> nil);
  {$ENDIF}
    @EwfMgrRestore := GetProcAddress(DLLHandle,'EwfMgrRestore');
  {$IFDEF WIN32}
    Assert(@EwfMgrRestore <> nil);
  {$ENDIF}
    @EwfMgrDisable := GetProcAddress(DLLHandle,'EwfMgrDisable');
  {$IFDEF WIN32}
    Assert(@EwfMgrDisable <> nil);
  {$ENDIF}
    @EwfMgrEnable := GetProcAddress(DLLHandle,'EwfMgrEnable');
  {$IFDEF WIN32}
    Assert(@EwfMgrEnable <> nil);
  {$ENDIF}
    @EwfMgrCommit := GetProcAddress(DLLHandle,'EwfMgrCommit');
  {$IFDEF WIN32}
    Assert(@EwfMgrCommit <> nil);
  {$ENDIF}
    @EwfMgrSetLevel := GetProcAddress(DLLHandle,'EwfMgrSetLevel');
  {$IFDEF WIN32}
    Assert(@EwfMgrSetLevel <> nil);
  {$ENDIF}
    @EwfMgrGetProtectedVolumeConfig := GetProcAddress(DLLHandle,'EwfMgrGetProtectedVolumeConfig');
  {$IFDEF WIN32}
    Assert(@EwfMgrGetProtectedVolumeConfig <> nil);
  {$ENDIF}
    @EwfMgrGetProtectedVolumeList := GetProcAddress(DLLHandle,'EwfMgrGetProtectedVolumeList');
  {$IFDEF WIN32}
    Assert(@EwfMgrGetProtectedVolumeList <> nil);
  {$ENDIF}
    @EwfMgrOpenOverlayStore := GetProcAddress(DLLHandle,'EwfMgrOpenOverlayStore');
  {$IFDEF WIN32}
    Assert(@EwfMgrOpenOverlayStore <> nil);
  {$ENDIF}
    @EwfMgrGetOverlayStoreConfig := GetProcAddress(DLLHandle,'EwfMgrGetOverlayStoreConfig');
  {$IFDEF WIN32}
    Assert(@EwfMgrGetOverlayStoreConfig <> nil);
  {$ENDIF}
    @EwfMgrRegisterLowSpaceNotification := GetProcAddress(DLLHandle,'EwfMgrRegisterLowSpaceNotification');
  {$IFDEF WIN32}
    Assert(@EwfMgrRegisterLowSpaceNotification <> nil);
  {$ENDIF}
  end
  else
  begin
    EwfDLLLoaded := False;
    { Error: EWFAPI.DLL could not be loaded !! }
  end;
{$IFNDEF MSDOS}
  SetErrorMode(ErrorMode)
{$ENDIF}
end {LoadDLL};

begin
//  LoadDLL;
end.
